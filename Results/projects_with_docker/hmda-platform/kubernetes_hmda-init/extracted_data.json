{
    "source_code_info": {
        "language": "Scala",
        "framework": "Scala",
        "dependencies": {
            "build.sbt": "import Dependencies._\nimport BuildSettings._\nimport sbtassembly.AssemblyPlugin.autoImport.assemblyMergeStrategy\nimport com.typesafe.sbt.packager.docker._\n\nlazy val commonDeps = Seq(logback, scalaTest, scalaCheck, akkaHttpSprayJson, testContainers, apacheCommonsIO, log4jToSlf4j, kubernetesApi)\n\nlazy val sparkDeps =\n  Seq(\n    postgres,\n    akkaKafkaStreams\n  )\n\nlazy val authDeps = Seq(keycloakAdapter, keycloak, keycloakAdmin, jbossLogging, httpClient)\n\nlazy val keycloakServerDeps = Seq(resteasyClient, resteasyJackson, resteasyMulti)\n\nlazy val akkaDeps = Seq(\n  akkaSlf4J,\n  akkaCluster,\n  akkaTyped,\n  akkaClusterTyped,\n  akkaStream,\n  akkaStreamTyped,\n  akkaManagement,\n  akkaManagementClusterBootstrap,\n  akkaServiceDiscoveryDNS,\n  akkaServiceDiscoveryKubernetes,\n  akkaClusterHttpManagement,\n  akkaClusterHttpManagement,\n  akkaTestkitTyped,\n  akkaStreamsTestKit,\n  akkaCors,\n  mskdriver,\n  akkaKafkaStreams,\n  embeddedKafka,\n  alpakkaS3,\n  akkaQuartzScheduler,\n  alpakkaFile\n)\n\nlazy val akkaPersistenceDeps =\n  Seq(\n    akkaPersistence,\n    akkaClusterSharding,\n    akkaPersistenceTyped,\n    akkaPersistenceQuery,\n    akkaClusterShardingTyped,\n    akkaPersistenceCassandra,\n    keyspacedriver,\n    cassandraLauncher\n  )\n\nlazy val akkaHttpDeps =\n  Seq(akkaHttp, akkaHttp2, akkaHttpXml, akkaHttpTestkit, akkaStreamsTestKit, akkaHttpCirce)\nlazy val circeDeps      = Seq(circe, circeGeneric, circeParser)\nlazy val enumeratumDeps = Seq(enumeratum, enumeratumCirce)\n\nlazy val slickDeps = Seq(slick, slickHikariCP, postgres, h2)\n\nlazy val dockerSettings = Seq(\n  dockerBuildCommand := {\n    //force amd64 Architecture for k8s docker image compatability\n    if (sys.props(\"os.arch\") != \"amd64\") {\n      dockerExecCommand.value ++ Seq(\"buildx\", \"build\", \"--platform=linux/amd64\", \"--load\") ++ dockerBuildOptions.value :+ \".\"\n    } else dockerBuildCommand.value\n  },\n  Docker / maintainer := \"Hmda-Ops\",\n  dockerBaseImage := \"eclipse-temurin:23.0.1_11-jdk-alpine\",\n  dockerRepository := Some(\"hmda\"),\n  dockerCommands := dockerCommands.value.flatMap {\n    case cmd@Cmd(\"FROM\",_) => List(cmd, Cmd(\"RUN\", \"apk update\"),\n      Cmd(\"RUN\", \"rm /var/cache/apk/*\"))\n    case other => List(other)\n  }\n)\n\n\nlazy val packageSettings = Seq(\n  // removes all jar mappings in universal and appends the fat jar\n  Universal / mappings := {\n    // universalMappings: Seq[(File,String)]\n    val universalMappings = (Universal / mappings).value\n    val fatJar            = (Compile / assembly).value\n    // removing means filtering\n    val filtered = universalMappings filter {\n      case (_, fileName) => !fileName.endsWith(\".jar\") || fileName.contains(\"cinnamon-agent\")\n    }\n    // add the fat jar\n    filtered :+ (fatJar -> (\"lib/\" + fatJar.getName))\n  },\n  // the bash scripts classpath only needs the fat jar\n  scriptClasspath := Seq((assembly / assemblyJarName).value)\n)\n\nlazy val `hmda-root` = (project in file(\".\"))\n  .settings(hmdaBuildSettings: _*)\n  .aggregate(\n    common,\n    `hmda-platform`,\n    `check-digit`,\n    `file-proxy`,\n    `institutions-api`,\n    `modified-lar`,\n    `hmda-analytics`,\n    `hmda-auth`,\n    `hmda-data-publisher`,\n    `hmda-reporting`,\n    `ratespread-calculator`,\n    `data-browser`,\n    `submission-errors`,\n    `hmda-quarterly-data-service`\n  )\n\nval latestGitTag = settingKey[String](\"The latest git tag.\")\nThisBuild / latestGitTag := {\n  import scala.sys.process._\n\n  val hasTags = \"git tag\".lineStream_!.nonEmpty\n\n  if (hasTags) {\n    \"git describe --tags\".lineStream_!.head\n  } else {\n    Keys.sLog.value.warn(\"No git tags in the checkout, using '-' for build info.\")\n    \"-\"\n  }\n}\n\nlazy val common = (project in file(\"common\"))\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Compile / PB.targets := Seq(\n      scalapb.gen() -> (Compile / sourceManaged).value / \"protobuf\"\n    ),\n    Seq(\n      libraryDependencies ++= commonDeps ++ authDeps ++ akkaDeps ++ akkaPersistenceDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++ List(\n        cormorant, cormorantGeneric, scalaMock, scalacheckShapeless, diffx\n      )\n    ),\n    addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\")\n    // addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\"),\n    // unmanagedJars in Compile ++= Seq(new java.io.File(\"/tmp/aws-msk-iam-auth-2.2.0-all.jar\")).classpath,\n    // unmanagedJars in Runtime ++= Seq(new java.io.File(\"/tmp/aws-msk-iam-auth-2.2.0-all.jar\")).classpath   \n  )\n  .enablePlugins(BuildInfoPlugin)\n  .settings(\n    buildInfoKeys := Seq[BuildInfoKey](name, version, scalaVersion, sbtVersion, latestGitTag),\n    buildInfoPackage := \"hmda\"\n  )\n\nlazy val `hmda-platform` = (project in file(\"hmda\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= List(guava, zeroAllocationHashing),\n      Compile / mainClass := Some(\"hmda.HmdaPlatform\"),\n      assembly / assemblyJarName := \"hmda2.jar\",\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"cinnamon-reference.conf\"               => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"logback.xml\"                           => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n     reStart / envVars ++= Map(\"CASSANDRA_CLUSTER_HOSTS\" -> \"localhost\", \"APP_PORT\" -> \"2551\"),\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n\nlazy val `check-digit` = (project in file(\"check-digit\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.uli.HmdaUli\"),\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      },\n      assembly / assemblyMergeStrategy := {\n\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs @ _*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs @ _*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n\n  lazy val `file-proxy` = (project in file(\"file-proxy\"))\n    .enablePlugins(\n      JavaServerAppPackaging,\n      sbtdocker.DockerPlugin,\n      AshScriptPlugin\n    )\n    .settings(hmdaBuildSettings: _*)\n    .settings(\n      Seq(\n        libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++\n        enumeratumDeps :+ monix :+ lettuce :+ scalaJava8Compat :+ scalaMock,\n        Compile / mainClass := Some(\"hmda.proxy.FileProxy\"),\n        assembly / assemblyJarName := {\n          s\"${name.value}.jar\"\n        },\n        assembly/ assemblyMergeStrategy := {\n          case \"application.conf\"                      => MergeStrategy.concat\n          case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n          case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n          case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n          case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n          case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n          case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n            MergeStrategy.first\n          case \"module-info.class\" => MergeStrategy.concat\n          case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n          case x =>\n            val oldStrategy = (assembly / assemblyMergeStrategy).value\n            oldStrategy(x)\n        }\n      ),\n      dockerSettings,\n      packageSettings\n    )\n    .dependsOn(common % \"compile->compile;test->test\")\n\n\nlazy val `institutions-api` = (project in file(\"institutions-api\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.institution.HmdaInstitutionApi\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n\nlazy val `hmda-data-publisher` = (project in file(\"hmda-data-publisher\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++ enumeratumDeps :+\n        scalaMock :+ cormorantGeneric :+ scalacheckShapeless :+ diffx,\n      Compile / mainClass := Some(\"hmda.publisher.HmdaDataPublisherApp\"),\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      },\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      }\n    ),\n    dockerSettings,\n    packageSettings,\n    addCompilerPlugin(\"com.olegpy\" %% \"better-monadic-for\" % \"0.3.1\")\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n\nlazy val `hmda-dashboard` = (project in file(\"hmda-dashboard\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++\n        enumeratumDeps :+ monix :+ lettuce :+ scalaJava8Compat :+ scalaMock,\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n\nlazy val `ratespread-calculator` = (project in file(\"ratespread-calculator\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.calculator.HmdaRateSpread\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n\nlazy val `modified-lar` = (project in file(\"modified-lar\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.publication.lar.ModifiedLarApp\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol`)\n  .dependsOn(common)\n\nlazy val `irs-publisher` = (project in file(\"irs-publisher\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.publication.lar.IrsPublisherApp\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol`)\n  .dependsOn(common)\n\nlazy val `hmda-reporting` = (project in file(\"hmda-reporting\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.reporting.HmdaReporting\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol`)\n  .dependsOn(common)\n\nlazy val `hmda-protocol` = (project in file(\"protocol\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin,\n    AkkaGrpcPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n\nlazy val `hmda-analytics` = (project in file(\"hmda-analytics\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.analytics.HmdaAnalyticsApp\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n\n  lazy val `hmda-auth` = (project in file(\"hmda-auth\"))\n    .enablePlugins(\n      JavaServerAppPackaging,\n      sbtdocker.DockerPlugin,\n      AshScriptPlugin\n    )\n    .settings(hmdaBuildSettings: _*)\n    .settings(\n      Seq(\n        libraryDependencies ++= keycloakServerDeps,\n        Compile / mainClass := Some(\"hmda.authService.HmdaAuth\"),\n        assembly / assemblyJarName := {\n          s\"${name.value}.jar\"\n        },\n        assembly / assemblyMergeStrategy := {\n          case \"application.conf\"                      => MergeStrategy.concat\n          case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n          case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n          case PathList(\"META-INF\", xs @ _*) => MergeStrategy.concat\n          case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n          case PathList(\"jakarta\", xs @ _*) => MergeStrategy.last\n          case \"reference.conf\" => MergeStrategy.concat\n          case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n            MergeStrategy.first\n          case \"module-info.class\" => MergeStrategy.concat\n          case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n          case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n          case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n        }\n      ),\n      dockerSettings,\n      packageSettings\n    )\n    .dependsOn(common % \"compile->compile;test->test\")\n    .dependsOn(`institutions-api` % \"compile->compile;test->test\")\n\nlazy val `rate-limit` = (project in file(\"rate-limit\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps :+ guava,\n      Compile / mainClass := Some(\"hmda.rateLimit.RateLimitApp\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol`)\n\nlazy val `data-browser` = (project in file(\"data-browser\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++\n        enumeratumDeps :+ monix :+ lettuce :+ scalaJava8Compat :+ scalaMock,\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n\nlazy val `submission-errors` = (project in file(\"submission-errors\"))\n  .enablePlugins(JavaServerAppPackaging, sbtdocker.DockerPlugin, AshScriptPlugin)\n  .settings(hmdaBuildSettings)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps :+ monix :+ slickPostgres,\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\" => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps@_*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\") // allows you to depend on code from both compile and test scopes\n\nlazy val `email-service` = (project in file(\"email-service\"))\n  .enablePlugins(JavaServerAppPackaging, sbtdocker.DockerPlugin, AshScriptPlugin)\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      Compile / mainClass := Some(\"hmda.publication.lar.EmailReceiptApp\"),\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      },\n      libraryDependencies ++= monix :: akkaKafkaStreams :: awsSesSdk :: logback :: Nil\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol`)\n\nlazy val `hmda-quarterly-data-service` = (project in file (\"hmda-quarterly-data-service\"))\n  .enablePlugins(\n    JavaServerAppPackaging,\n    sbtdocker.DockerPlugin,\n    AshScriptPlugin\n  )\n  .settings(hmdaBuildSettings: _*)\n  .settings(\n    Seq(\n      libraryDependencies ++= commonDeps ++ akkaDeps ++ akkaHttpDeps ++ circeDeps ++ slickDeps ++\n        enumeratumDeps :+ monix :+ lettuce :+ scalaJava8Compat :+ scalaMock,\n      assembly / assemblyMergeStrategy := {\n        case \"application.conf\"                      => MergeStrategy.concat\n        case \"META-INF/io.netty.versions.properties\" => MergeStrategy.concat\n        case \"META-INF/MANIFEST.MF\" => MergeStrategy.discard\n        case PathList(\"META-INF\", xs@_*) => MergeStrategy.concat\n        case PathList(\"org\", \"bouncycastle\", xs @_*) => MergeStrategy.first\n        case PathList(\"jakarta\", xs@_*) => MergeStrategy.last\n        case PathList(ps @ _*) if ps.last endsWith \".proto\" =>\n          MergeStrategy.first\n        case \"module-info.class\" => MergeStrategy.concat\n        case x if x.endsWith(\"/module-info.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LineTokenizer.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/LogSupport.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MailcapFile.class\") => MergeStrategy.concat\n        case x if x.endsWith(\"/MimeTypeFile.class\") => MergeStrategy.concat\n        case x =>\n          val oldStrategy = (assembly / assemblyMergeStrategy).value\n          oldStrategy(x)\n      },\n      assembly / assemblyJarName := {\n        s\"${name.value}.jar\"\n      }\n    ),\n    dockerSettings,\n    packageSettings\n  )\n  .dependsOn(common % \"compile->compile;test->test\")\n  .dependsOn(`hmda-protocol` % \"compile->compile;test->test\")\n"
        },
        "database": "PostgreSQL",
        "build_system": "sbt",
        "config_files": {
            "docker-compose.yml": "#version: \"3.7\"\n\nservices:\n\n  # ------------- Kafka -----------------\n  zookeeper:\n    image: wurstmeister/zookeeper\n    ports:\n      - \"2181:2181\"\n    logging:\n      driver: none\n\n  kafka:\n    image: wurstmeister/kafka\n    command: [\"wait-for-it.sh\", \"zookeeper:2181\", \"--\",\"start-kafka.sh\"]\n    ports:\n      - \"9092:9092\"\n    logging:\n      driver: none\n    depends_on:\n      - zookeeper\n    environment:\n      KAFKA_LISTENERS: INTERNAL://kafka:9092\n      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka:9092\n      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT\n      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL\n      KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181\n      # KAFKA_CREATE_TOPICS: institution\n      KAFKA_CREATE_GROUP: institutions-group\n      KAFKA_BROKER_ID: 2\n    volumes:\n      - ./wait-for-it.sh:/usr/bin/wait-for-it.sh\n      - db-data:/var/lib/kafka/data\n\n  # ------------- Cassandra -------------\n  cassandra:\n    image: \"cassandra:3.11.4\"\n    ports:\n      - \"9042:9042\"\n    logging:\n      driver: none\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock\n      - db-data:/var/lib/cassandra/data\n\n  # ------------- Cassandra CQLSH -------------\n  cassandra-cqlsh:\n    image: \"cassandra:3.11.4\"\n    depends_on:\n      - cassandra\n    entrypoint: /bin/bash \n    command:\n     - \"cqlsh-docker-run.sh\"\n    logging:\n      driver: none\n    volumes:\n      - ./cqlsh-docker-run.sh:/usr/bin/cqlsh-docker-run.sh\n      - ./hmda-sql-doc/dev-cassandra.cql:/tmp/dev-cassandra.cql\n\n  # ------------- HMDA Platform ---------\n  hmda-platform:\n    image: hmda/hmda-platform\n    ports:\n      - \"8080:8080\"\n      - \"8081:8081\"\n      - \"8082:8082\"\n    depends_on:\n      - kafka\n      - cassandra\n      - cassandra-cqlsh\n    command:\n      - \"wait-for-it.sh\"\n      - \"--service kafka:9092\"\n      - \"--services cassandra:9042\"\n    environment:\n      HMDA_RUNTIME_MODE: docker-compose\n      CASSANDRA_CLUSTER_HOSTS: cassandra\n      CASSANDRA_CLUSTER_DC: datacenter1\n      CASSANDRA_CLUSTER_PASSWORD: cassandra\n      CASSANDRA_CLUSTER_USERNAME: cassandra\n      CASSANDRA_JOURNAL_KEYSPACE: hmda2_journal\n      CASSANDRA_SNAPSHOT_KEYSPACE: hmda2_snapshot\n      KAFKA_CLUSTER_HOSTS: kafka:9092\n      KAFKA_INSTITUTIONS_TOPIC: institution\n      KAFKA_SIGN_TOPIC: hmda-sign\n    volumes:\n      - ./wait-for-it.sh:/usr/bin/wait-for-it.sh\n\n  # ------------- Postgres ---------\n  pg:\n    image: postgres\n    environment:\n      - POSTGRES_DB=hmda\n      - POSTGRES_HOST_AUTH_METHOD=trust\n    ports:\n      - 5432:5432\n    volumes:\n      - db-data:/var/lib/postgresql/data\n\n  # ------------- Institutions-API ---------\n  institutions-api:\n    image: hmda/institutions-api\n    depends_on:\n      - kafka\n      - cassandra\n      - pg\n    command:\n      - \"wait-for-it.sh\"\n      - \"--service pg:5432\"\n      - \"--service kafka:9092\"\n      - \"--services cassandra:9042\"\n    environment:\n      CASSANDRA_CLUSTER_HOSTS: cassandra:9042\n      CASSANDRA_CLUSTER_PASSWORD:\n      CASSANDRA_CLUSTER_USERNAME:\n      CASSANDRA_JOURNAL_KEYSPACE: hmda2_journal\n      CASSANDRA_SNAPSHOT_KEYSPACE: hmda2_snapshot\n      CASSANDRA_CLUSTER_DC: \n      KAFKA_CLUSTER_HOSTS: kafka:9092\n      KAFKA_INSTITUTIONS_TOPIC: institution\n      KAFKA_INSTITUTIONS_GROUP: institutions-group\n      PG_HOST: pg:5432\n      PG_DATABASE: hmda\n      PG_USER:\n      PG_PASSWORD:\n    volumes:\n      - ./wait-for-it.sh:/usr/bin/wait-for-it.sh\n\n  # ------------- HMDA Analytics ---------\n  hmda-analytics:\n    image: hmda/hmda-analytics\n    depends_on:\n      - kafka\n      - cassandra\n      - pg\n    command:\n      - \"wait-for-it.sh\"\n      - \"--service pg:5432\"\n      - \"--service kafka:9092\"\n      - \"--services cassandra:9042\"\n    environment:\n      CASSANDRA_CLUSTER_HOSTS: cassandra:9042\n      CASSANDRA_CLUSTER_PASSWORD:\n      CASSANDRA_CLUSTER_USERNAME:\n      CASSANDRA_JOURNAL_KEYSPACE: hmda2_journal\n      CASSANDRA_SNAPSHOT_KEYSPACE: hmda2_snapshot\n      KAFKA_CLUSTER_HOSTS: kafka:9092\n      KAFKA_INSTITUTIONS_TOPIC: institution\n      KAFKA_INSTITUTIONS_GROUP: institutions-group\n      PG_HOST: pg:5432\n      PG_DATABASE: hmda\n      PG_USER:\n      PG_PASSWORD:\n    volumes:\n      - ./wait-for-it.sh:/usr/bin/wait-for-it.sh\n\nvolumes:\n  db-data:\n    driver: local\n",
            "kubernetes/hmda-init/Dockerfile": "FROM eclipse-temurin:23.0.1_11-jdk-alpine\n\nRUN apk upgrade --update-cache --available && apk add openssl\nRUN adduser -H -S -G root -h /opt hmda\nRUN mkdir /opt/docker\nRUN chmod -R 777 /opt\nRUN chown -R hmda /opt\n\nUSER hmda"
        },
        "static_files": {}
    },
    "project_structure": {
        "files": [
            "Dockerfile",
            "README.md",
            "ambassador-mailhog.yaml"
        ],
        "folders": []
    }
}