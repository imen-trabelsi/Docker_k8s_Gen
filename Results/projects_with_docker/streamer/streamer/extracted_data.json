{
    "source_code_info": {
        "language": "JavaScript",
        "framework": "Node.js",
        "dependencies": {
            "package.json": "{\n  \"name\": \"streamer\",\n  \"description\": \"DCCN data streamer\",\n  \"version\": \"3.2.0\",\n  \"author\": \"Hurng-Chun Lee <h.lee@donders.ru.nl>\",\n  \"main\": \"streamer.js\",\n  \"dependencies\" : {\n    \"express\": \"~4.14.0\",\n    \"config\": \"~1.24.0\",\n    \"redis\": \"~2.6.3\",\n    \"kue\": \"~0.11.4\",\n    \"tree-kill\": \"~1.2.2\",\n    \"ncp\": \"~2.0.0\",\n    \"basic-auth\": \"~1.0.4\",\n    \"underscore\": \">=1.12.1\",\n    \"async\": \"~2.1.2\",\n    \"sleep\": \"~5.0.0\",\n    \"ldapjs\": \"~1.0.1\",\n    \"bunyan\": \"~1.8.4\",\n    \"activedirectory\": \"~0.7.2\",\n    \"ssh2\": \"~0.5.2\",\n    \"node-rest-client\": \"~2.0.1\",\n    \"body-parser\": \"~1.15.2\",\n    \"posix\": \"~4.1.1\",\n    \"orthanc-client\": \"~0.10.5\",\n    \"tar\": \"~4.4.2\",\n    \"nodemailer\": \"~4.0.1\",\n    \"node-html-encoder\": \"~0.0.2\",\n    \"node-emoji\": \"~1.5.1\"\n  }\n}\n"
        },
        "database": "Redis",
        "build_system": "npm",
        "config_files": {
            "docker-compose.yml": "version: '3.7'\nservices:\n  db:\n    build:\n      context: ./redis\n    image: ${DOCKER_REGISTRY:-dccn}/redis\n    user: root\n    volumes:\n      - ${STREAMER_DB_DATA_VOL}:/data\n  service:\n    build:\n      context: ./streamer\n    image: ${DOCKER_REGISTRY:-dccn}/streamer:${DOCKER_IMAGE_TAG:-latest}\n    user: root\n    environment:\n      - REDIS_HOST=db\n      - REDIS_PORT=6379\n      - STREAMER_SERVICE_PORT=${STREAMER_SERVICE_PORT:-3001}\n    volumes:\n      - ${STREAMER_SERVICE_LOG_VOL}:/opt/streamer/log\n      - ${STREAMER_SERVICE_CRON_VOL}:/cron\n      - ${HOME_VOL}:/home:ro\n      - ${PROJECT_VOL}:/project\n      - ${PROJECT_CEPHFS_VOL}:/project_cephfs\n    depends_on:\n      - db\n  ftp:\n    build:\n      context: ./streamer-ftp\n    image: ${DOCKER_REGISTRY:-dccn}/streamer-ftp:${DOCKER_IMAGE_TAG:-latest}\n    ports:\n      - ${STREAMER_FTP_EXTERNAL_PORT:-2222}:22\n    command: ${STREAMER_FTP_USERNAME:-streamer}:${STREAMER_FTP_PASSWORD:-streamer}:${STREAMER_FTP_UID:-1010}:${STREAMER_FTP_GID:-1010}:project\n  ui:\n    build:\n      context: ./streamer-ui\n    image: ${DOCKER_REGISTRY:-dccn}/streamer-ui:${DOCKER_IMAGE_TAG:-latest}\n    environment:\n      STREAMER_UI_AUTH_SERVER:\n      STREAMER_UI_AUTH_CLIENT_ID:\n      STREAMER_UI_AUTH_CLIENT_SECRET:\n      STREAMER_UI_PDB_VERSION:\n      STREAMER_UI_EXTERNAL_PORT:\n      STREAMER_UI_BUFFER_DIR:\n      STREAMER_URL_PREFIX:\n      STREAMER_UI_DB_HOST:\n      STREAMER_UI_DB_PORT:\n      STREAMER_UI_DB_USER:\n      STREAMER_UI_DB_PASSWORD:\n      STREAMER_UI_DB_NAME:\n      STREAMER_UI_DEBUG:\n    depends_on:\n      - service\n      - ui-db\n  ui-db:\n    image: postgres:12-alpine\n    environment:\n      POSTGRES_HOST:\n      POSTGRES_PORT:\n      POSTGRES_USER:\n      POSTGRES_PASSWORD:\n      POSTGRES_DATABASE:\n      GRAFANA_USER:\n      GRAFANA_PASSWORD:\n    volumes:\n      - ${STREAMER_UI_DB_INIT_VOL}/01-initialize-database.sh:/docker-entrypoint-initdb.d/01-initialize-database.sh:ro\n    restart: always\n",
            "docker-compose.override.yml": "version: '3.7'\nservices:\n  ui:\n    build:\n      context: ./streamer-ui\n    image: ${DOCKER_REGISTRY:-dccn}/streamer-ui:${DOCKER_IMAGE_TAG:-latest}\n    ports:\n      - ${STREAMER_UI_EXTERNAL_PORT:-9000}:9000\n    volumes:\n      - ${STREAMER_UI_LOG_VOL}:/opt/streamer-ui-server/log\n  ui-db:\n    ports:\n      - ${STREAMER_UI_DB_PORT:-5432}:${STREAMER_UI_DB_PORT:-5432}\n    volumes:\n      - /var/lib/postgresql/data\n",
            "streamer/Dockerfile": "FROM almalinux:8\n\n# application metadata\nLABEL donders.ru.nl.app_name \"streamer\"\nLABEL donders.ru.nl.app_maintainer \"h.lee@donders.ru.nl\"\nLABEL donders.ru.nl.app_code_repository \"https://github.com/Donders-Institute/data-streamer\"\n\n# install required packages from YUM repository\nRUN ( ulimit -n 1024 && yum -y install wget gcc gcc-c++ \\\n      make autoconf git zlib zlib-devel \\\n      openssl openssl-devel openssl-libs \\\n      sssd-client which rsync \\\n      curl curl-devel libxml2-devel epel-release \\\n   && yum clean all \\\n   && rm -rf /var/cache/yum/* \\\n   && rm -rf /tmp/* )\n\nRUN ( ulimit -n 1024 && yum -y install supervisor sshpass pv expect \\\n   && yum clean all \\\n   && rm -rf /var/cache/yum/* \\\n   && rm -rf /tmp/* )\n\n# create temporary directory\nRUN ( mkdir -p /tmp )\nWORKDIR /tmp\n\n# install nodejs\n#ADD https://nodejs.org/dist/v8.12.0/node-v8.12.0-linux-x64.tar.xz /tmp\n#RUN ( if [ ! -d node-v8.12.0-linux-x64 ]; then tar xf node-v8.12.0-linux-x64.tar.xz; fi \\\n#      && mv node-v8.12.0-linux-x64 /opt/nodejs )\n\nADD https://nodejs.org/dist/latest-v10.x/node-v10.24.1-linux-x64.tar.xz /tmp\n\nRUN ( if [ ! -d node-v10.24.1-linux-x64 ]; then tar xf node-v10.24.1-linux-x64.tar.xz; fi \\\n      && mv node-v10.24.1-linux-x64 /opt/nodejs && rm -rf /tmp/node-*)\n\n# install streamer package\nRUN ( mkdir -p /opt/streamer )\n\nWORKDIR /opt/streamer\nCOPY package.json package.json\nRUN ( export PATH=/opt/nodejs/bin:$PATH && export USER=root && /opt/nodejs/bin/npm install -g node-gyp && /opt/nodejs/bin/npm install -g --unsafe-perm)\nCOPY *.js ./\nCOPY bin ./bin\nCOPY lib ./lib\nCOPY config ./config\nCOPY start_streamer.sh start_streamer.sh\nRUN ( chmod +x bin/* )\nRUN ( chmod +x start_streamer.sh )\n\n# supervisor configuration\nCOPY supervisord.conf /opt/streamer/supervisord.conf\n\n# run devcron from supervisor\nVOLUME [ \"/project\", \"/cron\", \"/opt/streamer/config\", \"/opt/streamer/log\" ]\n\n# main executable\nCMD [ \"/usr/bin/supervisord\", \"-c\", \"/opt/streamer/supervisord.conf\" ]\n",
            "Jenkinsfile": "// STACK_NAME defines the name of the Docker stack deployed to acceptance\ndef STACK_NAME=\"lab-data-streamer\"\n\npipeline {\n    agent any\n\n    environment {\n        DOCKER_IMAGE_TAG = \"jenkins-${env.BUILD_NUMBER}\"\n    }\n    \n    options {\n        disableConcurrentBuilds()\n    }\n\n    stages {\n        stage('Build') {\n            when {\n                expression {\n                    return !params.PRODUCTION\n                }\n            }\n            agent {\n                label 'swarm-manager'\n            }\n            steps {\n                sh 'docker-compose build --parallel'\n            }\n            post {\n                success {\n                    withCredentials([\n                        usernamePassword (\n                            credentialsId: params.PLAYGROUND_DOCKER_REGISTRY_CREDENTIALS,\n                            usernameVariable: 'DOCKER_USERNAME',\n                            passwordVariable: 'DOCKER_PASSWORD'\n                        )\n                    ]){\n                        sh \"docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD} ${DOCKER_REGISTRY}\"\n                        sh (\n                            label: \"Pushing images to repository '${env.DOCKER_REGISTRY}'\",\n                            script: 'docker-compose push'\n                        )\n                    }\n                }\n            }\n        }\n\n        stage('Build (PRODUCTION)') {\n            when {\n                expression {\n                    return params.PRODUCTION\n                }\n            }\n            agent {\n                label 'swarm-manager'\n            }\n            steps {\n                withEnv([\n                    \"DOCKER_REGISTRY=${params.PRODUCTION_DOCKER_REGISTRY}\",\n                    \"DOCKER_IMAGE_TAG=${params.PRODUCTION_GITHUB_TAG}\"\n                ]) {\n                    sh 'docker-compose build --parallel'\n                } \n            }\n        }\n\n        stage('Staging') {\n             when {\n                expression {\n                    return !params.PRODUCTION\n                }\n            }\n            agent {\n                label 'swarm-manager'\n            }\n            steps {\n\n                sh \"docker stack rm ${STACK_NAME}\"\n                \n                sleep(30)\n\n                withCredentials([\n                    usernamePassword (\n                        credentialsId: params.STREAMER_UI_DB_CREDENTIALS,\n                        usernameVariable: 'STREAMER_UI_DB_USER',\n                        passwordVariable: 'STREAMER_UI_DB_PASSWORD'\n                    ),\n                    usernamePassword (\n                        credentialsId: params.STREAMER_UI_DB_READ_ONLY_CREDENTIALS,\n                        usernameVariable: 'GRAFANA_USER',\n                        passwordVariable: 'GRAFANA_PASSWORD'\n                    ),\n                    usernamePassword (\n                        credentialsId: params.STREAMER_UI_DB_CREDENTIALS,\n                        usernameVariable: 'POSTGRES_USER',\n                        passwordVariable: 'POSTGRES_PASSWORD'\n                    )\n                ]) {\n                    // Overwrite the env.sh file to be stored later as an artifact\n                    script {\n                        def statusCode = sh(script: \"bash ./print_env.sh > ${WORKSPACE}/env.sh\", returnStatus: true)\n                        echo \"statusCode: ${statusCode}\"\n                    }\n\n                    // Use the same approach as for production\n                    script {\n                        def statusCode = sh(script: \"bash ./docker-deploy-acceptance.sh ${STACK_NAME}\", returnStatus: true)\n                        echo \"statusCode: ${statusCode}\"\n                    }\n                }\n            }\n        }\n\n        stage('Health check') {\n            when {\n                expression {\n                    return !params.PRODUCTION\n                }\n            }\n            agent {\n                label 'swarm-manager'\n            }\n            steps {\n                withDockerContainer(image: 'jwilder/dockerize', args: \"--network ${STACK_NAME}_default\") {\n                    sh (\n                        label: 'Waiting for services to become available',\n                        script: 'dockerize \\\n                            -timeout 120s \\\n                            -wait tcp://service:3001 \\\n                            -wait tcp://ui-db:5432 \\\n                            -wait http://ui:9000 \\\n                            -wait http://stager-api-server:8080/v1/ping'\n                    )\n                }\n            }\n            post {\n                failure {\n                    sh (\n                        label: 'Displaying service status',\n                        script: \"docker stack ps ${STACK_NAME}\"\n                    )\n                    sh (\n                        label: 'Displaying service logs',\n                        script: \"docker stack services --format '{{.Name}}' ${STACK_NAME} | xargs -n 1 docker service logs\"\n                    )\n                }\n            }\n        }\n\n        stage('Tag and push (PRODUCTION)') {\n            when {\n                expression {\n                    return params.PRODUCTION\n                }\n            }\n            agent {\n                label 'swarm-manager'\n            }\n            steps {\n                echo \"production: true\"\n                echo \"production github tag: ${params.PRODUCTION_GITHUB_TAG}\"\n\n                // Handle Github tags\n                withCredentials([\n                    usernamePassword (\n                        credentialsId: params.GITHUB_CREDENTIALS,\n                        usernameVariable: 'GITHUB_USERNAME',\n                        passwordVariable: 'GITHUB_PASSWORD'\n                    )\n                ]) {\n                    // Remove local tag (if any)\n                    script {\n                        def statusCode = sh(script: \"git tag --list | grep ${params.PRODUCTION_GITHUB_TAG}\", returnStatus: true)\n                        if(statusCode == 0) {\n                            sh \"git tag -d ${params.PRODUCTION_GITHUB_TAG}\"\n                            echo \"Removed existing local tag ${params.PRODUCTION_GITHUB_TAG}\"\n                        }\n                    }\n                    \n                    // Create local tag\n                    sh \"git tag -a ${params.PRODUCTION_GITHUB_TAG} -m 'jenkins'\"\n                    echo \"Created local tag ${params.PRODUCTION_GITHUB_TAG}\"\n\n                    // Remove remote tag (if any)\n                    script {\n                        def result = sh(script: \"git ls-remote https://${GITHUB_USERNAME}:${GITHUB_PASSWORD}@github.com/Donders-Institute/data-streamer.git refs/tags/${params.PRODUCTION_GITHUB_TAG}\", returnStdout: true).trim()\n                        if (result != \"\") {\n                            sh \"git push --delete https://${GITHUB_USERNAME}:${GITHUB_PASSWORD}@github.com/Donders-Institute/data-streamer.git ${params.PRODUCTION_GITHUB_TAG}\"\n                            echo \"Removed existing remote tag ${params.PRODUCTION_GITHUB_TAG}\"\n                        }\n                    }\n\n                    // Create remote tag\n                    sh \"git push https://${GITHUB_USERNAME}:${GITHUB_PASSWORD}@github.com/Donders-Institute/data-streamer.git ${params.PRODUCTION_GITHUB_TAG}\"\n                    echo \"Created remote tag ${params.PRODUCTION_GITHUB_TAG}\"\n                }\n\n                // Override the env variables and \n                // push the Docker images to the production Docker registry\n                withEnv([\n                    \"DOCKER_REGISTRY=${params.PRODUCTION_DOCKER_REGISTRY}\",\n                    \"DOCKER_IMAGE_TAG=${params.PRODUCTION_GITHUB_TAG}\"\n                ]) {\n                    withCredentials([\n                        usernamePassword (\n                            credentialsId: params.PRODUCTION_DOCKER_REGISTRY_CREDENTIALS,\n                            usernameVariable: 'DOCKER_USERNAME',\n                            passwordVariable: 'DOCKER_PASSWORD'\n                        )\n                    ]) {\n                        sh \"docker login -u ${DOCKER_USERNAME} -p ${DOCKER_PASSWORD} ${params.PRODUCTION_DOCKER_REGISTRY}\"\n                        sh 'docker-compose push'\n                        echo \"Pushed images to ${DOCKER_REGISTRY}\"\n                    }\n                } \n            }\n        }\n    }\n\n    post {\n        success {\n            archiveArtifacts \"docker-compose.yml, docker-compose.stager.yml, docker-compose.swarm.yml, env.sh\"\n        }\n        always {\n            echo 'cleaning'\n            sh 'docker system prune -f'\n        }\n    }\n}\n"
        },
        "static_files": {}
    },
    "project_structure": {
        "files": [
            "Dockerfile",
            "sshd_config"
        ],
        "folders": []
    }
}