{
    "source_code_info": {
        "language": "Java",
        "framework": "Java",
        "dependencies": {
            "build.gradle": "/*\n * Copyright Hyperledger Besu contributors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n\nimport com.github.jk1.license.filter.LicenseBundleNormalizer\nimport groovy.transform.CompileStatic\nimport groovy.transform.Memoized\nimport net.ltgt.gradle.errorprone.CheckSeverity\n\nimport java.text.SimpleDateFormat\nimport java.util.regex.Pattern\n\nplugins {\n  id 'com.diffplug.spotless' version '7.0.2'\n  id 'com.github.jk1.dependency-license-report' version '2.9'\n  id 'com.jfrog.artifactory' version '5.2.5'\n  id 'me.champeau.jmh' version '0.7.2' apply false\n  id 'net.ltgt.errorprone' version '4.1.0'\n  id 'maven-publish'\n  id 'jacoco'\n  id 'jacoco-report-aggregation'\n  id 'org.sonarqube' version '6.0.1.5171'\n}\n\nsonarqube {\n  properties {\n    property \"sonar.projectKey\", \"$System.env.SONAR_PROJECT_KEY\"\n    property \"sonar.organization\", \"$System.env.SONAR_ORGANIZATION\"\n    property \"sonar.gradle.skipCompile\", \"true\"\n    property \"sonar.host.url\", \"https://sonarcloud.io\"\n    property \"sonar.coverage.jacoco.xmlReportPaths\", \"${buildDir}/reports/jacoco/testCodeCoverageReport/testCodeCoverageReport.xml\"\n    property \"sonar.coverage.exclusions\", \"acceptance-tests/**/*\"\n  }\n}\n\nproject.tasks[\"sonar\"].dependsOn \"testCodeCoverageReport\"\n\nif (!JavaVersion.current().isCompatibleWith(JavaVersion.VERSION_21)) {\n  throw new GradleException(\"Java 21 or later is required to build Besu.\\n\" +\n  \"  Detected version ${JavaVersion.current()}\")\n}\n\ngroup = 'org.hyperledger.besu'\n\ndefaultTasks 'build', 'checkLicense', 'javadoc'\n\ndef buildAliases = [\n  'dev': [\n    'spotlessApply',\n    'build',\n    'checkLicense',\n    'javadoc'\n  ],\n  'build': ['spotlessCheck', 'build']\n]\n\ndef expandedTaskList = []\ngradle.startParameter.taskNames.each {\n  expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)\n}\ngradle.startParameter.taskNames = expandedTaskList.flatten()\n\n// Gets an integer command argument, passed with -Pname=x, or the default if not provided.\ndef _intCmdArg(name, defaultValue) {\n  return project.hasProperty(name) ? project.property(name) as int : defaultValue\n}\n\ndef _intCmdArg(name) {\n  return _intCmdArg(name, null)\n}\n\ndef _strListCmdArg(name, defaultValue) {\n  if (!project.hasProperty(name))\n    return defaultValue\n\n  return ((String) project.property(name)).tokenize(',')\n}\n\ndef _strListCmdArg(name) {\n  return _strListCmdArg(name, null)\n}\n\n// set the shell command to use according to os\ndef shell = org.gradle.internal.os.OperatingSystem.current().isWindows() ? \"${projectDir}\\\\wslsh.bat\" : '/bin/bash'\n\nlicenseReport {\n  // This is for the allowed-licenses-file in checkLicense Task\n  // Accepts File, URL or String path to local or remote file\n  allowedLicensesFile = new File(\"$rootDir/gradle/allowed-licenses.json\")\n\n  excludes = [\n    // only used for static analysis, not actually shipped\n    'com.google.errorprone:javac',\n    'org.checkerframework:dataflow-shaded',\n    'org.checkerframework:dataflow-errorprone',\n    // exclude Kotlin multiplatform dependencies container, they have the same license of what they contain\n    'com.squareup.okio:okio',\n    'org.jetbrains.kotlinx:kotlinx-coroutines-core'\n  ]\n\n  // If set to true, then all boms will be excluded from the report\n  excludeBoms = true\n\n  filters = [\n    new LicenseBundleNormalizer(bundlePath: \"$rootDir/gradle/license-normalizer-bundle.json\")\n  ]\n}\n\nconfigure(allprojects - project(':platform')) {\n  apply plugin: 'java-library'\n  apply plugin: 'jacoco'\n  apply plugin: 'net.ltgt.errorprone'\n\n  version = calculateVersion()\n\n  jacoco {\n    toolVersion = '0.8.11'\n    if (project.tasks.findByName('referenceTests')) {\n      applyTo referenceTests\n    }\n  }\n\n  task sourcesJar(type: Jar, dependsOn: classes) {\n    archiveClassifier = 'sources'\n    from sourceSets.main.allSource\n  }\n\n  task javadocJar(type: Jar, dependsOn: javadoc) {\n    archiveClassifier = 'javadoc'\n    from javadoc.outputDirectory\n  }\n\n  tasks.build {\n    dependsOn 'javadoc'\n  }\n\n  java {\n    sourceCompatibility = 21\n    targetCompatibility = 21\n  }\n\n  repositories {\n    maven {\n      url 'https://hyperledger.jfrog.io/hyperledger/besu-maven'\n      content { includeGroupByRegex('org\\\\.hyperledger\\\\..*') }\n    }\n    maven {\n      url 'https://artifacts.consensys.net/public/maven/maven/'\n      content { includeGroupByRegex('tech\\\\.pegasys(\\\\..*)?') }\n    }\n    maven {\n      url 'https://splunk.jfrog.io/splunk/ext-releases-local'\n      content { includeGroupByRegex('com\\\\.splunk\\\\..*') }\n    }\n\n    mavenCentral()\n\n    // ethereum execution spec tests fixtures. Exclusively for ethereum submodule to run ref tests\n    def ethExecSpecTestsRepo = ivy {\n      url 'https://github.com'\n      patternLayout {\n        artifact '/[organisation]/[module]/releases/download/v[revision]/[classifier].[ext]'\n      }\n      metadataSources {\n        artifact()\n      }\n    }\n    exclusiveContent {\n      forRepositories(ethExecSpecTestsRepo)\n      filter { includeModule('ethereum', 'execution-spec-tests')}\n    }\n  }\n\n  dependencies {\n    api platform(project(':platform'))\n\n    annotationProcessor(platform(project(':platform')))\n\n    testAnnotationProcessor(platform(project(':platform')))\n\n    components.all(BouncyCastleCapability)\n    errorprone 'com.google.errorprone:error_prone_core'\n    // https://github.com/hyperledger/besu-errorprone-checks/\n    errorprone \"org.hyperledger.besu:besu-errorprone-checks\"\n  }\n\n  configurations.all {\n    resolutionStrategy.capabilitiesResolution.withCapability('org.bouncycastle:bcprov-jdk18on') {\n      selectHighestVersion()\n    }\n    resolutionStrategy.capabilitiesResolution.withCapability('org.bouncycastle:bcpkix-jdk18on') {\n      selectHighestVersion()\n    }\n  }\n\n\n  apply plugin: 'com.diffplug.spotless'\n  spotless {\n    java {\n      // This path needs to be relative to each project\n      target 'src/**/*.java'\n      targetExclude '**/src/reference-test/**', '**/src/main/generated/**', '**/src/test/generated/**', '**/src/jmh/generated/**'\n      removeUnusedImports()\n      googleJavaFormat('1.25.2')\n      importOrder 'org.hyperledger', 'java', ''\n      trimTrailingWhitespace()\n      endWithNewline()\n      // apply appropriate license header files.\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.former.license\").named(\"older\").onlyIfContentMatches(\"^/\\\\*\\\\r?\\\\n.*Copyright ConsenSys AG\\\\.\")\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.former.date.license\").named(\"older.year\").onlyIfContentMatches(\"^/\\\\*\\\\r?\\\\n.* Copyright \\\\d{4} ConsenSys AG\\\\.\")\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.current.license\").named(\"current\").onlyIfContentMatches(\"^(?!/\\\\*\\\\r?\\\\n \\\\*.*(ConsenSys AG|Hyperledger Besu)\\\\.)\")\n    }\n    // spotless check applied to build.gradle (groovy) files\n    groovyGradle {\n      target '*.gradle'\n      greclipse('4.31').configFile(rootProject.file('gradle/spotless/greclipse.properties'))\n      endWithNewline()\n    }\n    // Below this line are currently only license header tasks\n    format 'ShellScripts', {\n      target '**/*.sh'\n      targetExclude '**/src/reference-test/**', '**/src/main/generated/**', '**/src/test/generated/**', '**/src/jmh/generated/**'\n      trimTrailingWhitespace()\n      endWithNewline()\n\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/sh.license\",\"^(?!##).+\").skipLinesMatching(\"^#!.+?\\$\")\n    }\n    format 'Solidity', {\n      target '**/*.sol'\n      targetExclude '**/src/reference-test/**', '**/src/main/generated/**', '**/src/test/generated/**', '**/src/jmh/generated/**'\n      trimTrailingWhitespace()\n      endWithNewline()\n\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.former.license\",\"^pragma solidity.+?\").named(\"former\").onlyIfContentMatches(\"^/\\\\*\\\\r?\\\\n.*Copyright ConsenSys AG\\\\.\")\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.former.date.license\",\"^pragma solidity.+?\").named(\"former.date\").onlyIfContentMatches(\"^/\\\\*\\\\r?\\\\n.* Copyright \\\\d{4} ConsenSys AG\\\\.\")\n      licenseHeaderFile(\"${rootDir}/gradle/spotless/java.current.license\",\"^pragma solidity.+?\").named(\"current\").onlyIfContentMatches(\"^(?!/\\\\*\\\\r?\\\\n \\\\*.*(ConsenSys AG|Hyperledger Besu)\\\\.)\")\n    }\n  }\n\n  tasks.withType(JavaCompile).configureEach {\n    options.compilerArgs += [\n      '-Xlint:unchecked',\n      '-Xlint:cast',\n      '-Xlint:rawtypes',\n      '-Xlint:overloads',\n      '-Xlint:divzero',\n      '-Xlint:finally',\n      '-Xlint:static',\n      '-Werror',\n    ]\n\n    options.errorprone {\n      excludedPaths = '.*/generated/*.*'\n      disableWarningsInGeneratedCode = true\n      // Our equals need to be symmetric, this checker doesn't respect that.\n      check('EqualsGetClass', CheckSeverity.OFF)\n      // We like to use futures with no return values.\n      check('FutureReturnValueIgnored', CheckSeverity.OFF)\n      // We use the JSR-305 annotations instead of the Google annotations.\n      check('ImmutableEnumChecker', CheckSeverity.OFF)\n      // This is a style check instead of an error-prone pattern.\n      check('UnnecessaryParentheses', CheckSeverity.OFF)\n\n      // This check is broken in Java 12.  See https://github.com/google/error-prone/issues/1257\n      if (JavaVersion.current() == JavaVersion.VERSION_12) {\n        check('Finally', CheckSeverity.OFF)\n      }\n      // This check is broken after Java 12.  See https://github.com/google/error-prone/issues/1352\n      if (JavaVersion.current() > JavaVersion.VERSION_12) {\n        check('TypeParameterUnusedInFormals', CheckSeverity.OFF)\n      }\n\n      check('FieldCanBeFinal', CheckSeverity.WARN)\n      check('InsecureCryptoUsage', CheckSeverity.WARN)\n      check('WildcardImport', CheckSeverity.WARN)\n    }\n\n    options.encoding = 'UTF-8'\n  }\n\n  // IntelliJ workaround to allow repeated debugging of unchanged code\n  tasks.withType(JavaExec) {\n    if (it.name.contains(\".\")) {\n      outputs.upToDateWhen { false }\n    }\n  }\n\n  /*\n   * Pass some system properties provided on the gradle command line to test executions for\n   * convenience.\n   *\n   * The properties passed are:\n   * - 'test.ethereum.include': allows to run a single Ethereum reference tests. For instance,\n   *   running a single general state test can be done with:\n   *    ./gradlew :ethereum:org.hyperledger.besu.ethereum.vm:test -Dtest.single=GeneralStateTest -Dtest.ethereum.include=callcodecallcallcode_101-Frontier\n   *   The meaning being that will be run only the tests for which the value passed as \"include\"\n   *   (which can be a java pattern) matches parts of the test name. Knowing that tests names for\n   *   reference tests are of the form:\n   *     <name>(-<milestone>([<variant>])?)?\n   *   where <name> is the test name as defined in the json file (usually the name of the json file\n   *   as well), <milestone> is the Ethereum milestone tested (not all test use it) and <variant>\n   *   is only use in some general state tests where for the same json file and same milestone,\n   *   multiple variant of that test are run. The variant is a simple number.\n   * - 'test.ethereum.state.eip': for general state tests, allows to only run tests for the\n   *   milestone specified by this value. So for instance,\n   *    ./gradlew :ethereum:org.hyperledger.besu.ethereum.vm:test -Dtest.single=GeneralStateTest -Dtest.ethereum.state.eip=Frontier\n   *   only run general state tests for Frontier. Note that this behavior could be achieved as well\n   *   with the 'include' option above since it is a pattern, but this is a slightly more convenient\n   *   option.\n   * - 'root.log.level' and 'evm.log.level': allow to control the log level used during the tests.\n   * - 'acctests.keepLogsOfPassingTests': log files of failed acceptance tests are always saved.\n   *    This property additionally keeps the log files of successful tests.\n   *\n   */\n  test {\n    jvmArgs += [\n      '-Xmx4g',\n      '-XX:-UseGCOverheadLimit',\n      // Mockito and jackson-databind do some strange reflection during tests.\n      // This suppresses an illegal access warning.\n      '--add-opens',\n      'java.base/java.util=ALL-UNNAMED',\n      '--add-opens',\n      'java.base/java.util.concurrent=ALL-UNNAMED',\n      '--add-opens',\n      'java.base/java.util.concurrent.atomic=ALL-UNNAMED',\n      // errorprone tests need access to the javac compiler\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.parser=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED',\n      '--add-exports',\n      'jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED'\n    ]\n    Set toImport = [\n      'test.ethereum.include',\n      'test.ethereum.state.eip',\n      'root.log.level',\n      'evm.log.level',\n      'acctests.keepLogsOfPassingTests'\n    ]\n    for (String name : toImport) {\n      if (System.getProperty(name) != null) {\n        systemProperty name, System.getProperty(name)\n      }\n    }\n    useJUnitPlatform {}\n    finalizedBy jacocoTestReport // report is always generated after tests run\n  }\n\n  javadoc {\n    options.addBooleanOption('Xdoclint:all', true)\n    // disable doc lint checking for generated code and acceptance tests dsl.\n    options.addBooleanOption('Xdoclint/package:-org.hyperledger.besu.privacy.contracts.generated,' +\n      '-org.hyperledger.besu.tests.acceptance.*,' +\n      '-org.hyperledger.besu.tests.web3j.generated,' +\n      // TODO: these are temporary excluded from lint (ethereum sub modules), it should be removed in a future PR.\n      // ethereum api module\n      '-org.hyperledger.besu.ethereum.api.handlers,' +\n      '-org.hyperledger.besu.ethereum.api.jsonrpc,' +\n      '-org.hyperledger.besu.ethereum.api.jsonrpc.*,' +\n      '-org.hyperledger.besu.ethereum.api.query,' +\n      '-org.hyperledger.besu.ethereum.api.query.*,' +\n      '-org.hyperledger.besu.ethereum.api.tls,' +\n      '-org.hyperledger.besu.ethereum.api.util,' +\n      // ethereum blockcreation module\n      '-org.hyperledger.besu.ethereum.blockcreation,' +\n      '-org.hyperledger.besu.ethereum.blockcreation.*,' +\n      // ethereum core module\n      '-org.hyperledger.besu.ethereum.chain,' +\n      '-org.hyperledger.besu.ethereum.core,' +\n      '-org.hyperledger.besu.ethereum.core.*,' +\n      '-org.hyperledger.besu.ethereum.debug,' +\n      '-org.hyperledger.besu.ethereum.difficulty.fixed,' +\n      '-org.hyperledger.besu.ethereum.forkid,' +\n      '-org.hyperledger.besu.ethereum.mainnet,' +\n      '-org.hyperledger.besu.ethereum.mainnet.*,' +\n      '-org.hyperledger.besu.ethereum.privacy,' +\n      '-org.hyperledger.besu.ethereum.privacy.*,' +\n      '-org.hyperledger.besu.ethereum.processing,' +\n      '-org.hyperledger.besu.ethereum.proof,' +\n      '-org.hyperledger.besu.ethereum.storage,' +\n      '-org.hyperledger.besu.ethereum.storage.*,' +\n      '-org.hyperledger.besu.ethereum.transaction,' +\n      '-org.hyperledger.besu.ethereum.trie.*,' +\n      '-org.hyperledger.besu.ethereum.util,' +\n      '-org.hyperledger.besu.ethereum.vm,' +\n      '-org.hyperledger.besu.ethereum.worldstate,' +\n      // ethereum eth module\n      '-org.hyperledger.besu.ethereum.eth.*,' +\n      '-org.hyperledger.besu.ethereum.eth,' +\n      '-org.hyperledger.besu.consensus.merge,' +\n      // p2p module\n      '-org.hyperledger.besu.ethereum.p2p,' +\n      '-org.hyperledger.besu.ethereum.p2p.*,' +\n      // permissioning module\n      '-org.hyperledger.besu.ethereum.permissioning,' +\n      '-org.hyperledger.besu.ethereum.permissioning.*,' +\n      // referencetests module\n      '-org.hyperledger.besu.ethereum.referencetests,' +\n      //rlp module\n      '-org.hyperledger.besu.ethereum.rlp,' +\n      // stratum module\n      '-org.hyperledger.besu.ethereum.stratum,' +\n      // trie module\n      '-org.hyperledger.besu.ethereum.trie.*,' +\n      '-org.hyperledger.besu.ethereum.trie,' +\n      // verkle trie module\n      '-org.hyperledger.besu.ethereum.verkletrie,' +\n      '-org.hyperledger.besu.ethereum.verkletrie.*',\n      true)\n    options.addStringOption('Xmaxerrs','65535')\n    options.addStringOption('Xmaxwarns','65535')\n    options.addStringOption('Xwerror', '-html5')\n    options.encoding = 'UTF-8'\n  }\n}\n\ntask deploy() {}\n\ntask checkMavenCoordinateCollisions {\n  doLast {\n    def coordinates = [:]\n    getAllprojects().forEach {\n      if (it.properties.containsKey('publishing')) {\n        if(!it.properties.containsKey('jar') || it.jar.enabled) {\n          def coordinate = it.publishing?.publications[0].coordinates\n          if (coordinate.toString().startsWith(\"org\") && coordinates.containsKey(coordinate)) {\n            throw new GradleException(\"Duplicate maven coordinates detected, ${coordinate} is used by \" +\n            \"both ${coordinates[coordinate]} and ${it.path}.\\n\" +\n            \"Please add a `publishing` script block to one or both subprojects.\")\n          }\n          coordinates[coordinate] = it.path\n        }\n      }\n    }\n  }\n}\n\ntasks.register('checkPluginAPIChanges', DefaultTask) {}\ncheckPluginAPIChanges.dependsOn(':plugin-api:checkAPIChanges')\ncheck.dependsOn('checkPluginAPIChanges', 'checkMavenCoordinateCollisions')\n\nsubprojects {\n\n  if (file('src/test-support').directory) {\n    sourceSets {\n      // test-support can be consumed as a library by other projects in their tests\n      testSupport {\n        java {\n          compileClasspath += main.output\n          runtimeClasspath += main.output\n          srcDir file('src/test-support/java')\n        }\n        resources.srcDir file('src/test-support/resources')\n      }\n    }\n\n    dependencies { testImplementation sourceSets.testSupport.output }\n\n    task testSupportJar(type: Jar) {\n      archiveBaseName = \"${project.name}-support-test\"\n      archiveClassifier = 'test-support'\n      from sourceSets.testSupport.output\n    }\n  }\n\n  if (file('src/integration-test').directory) {\n    sourceSets {\n      integrationTest {\n        java {\n          compileClasspath += main.output\n          runtimeClasspath += main.output\n          srcDir file('src/integration-test/java')\n        }\n        resources.srcDir file('src/integration-test/resources')\n      }\n    }\n\n    if (file('src/test-support').directory) {\n      dependencies { integrationTestImplementation sourceSets.testSupport.output }\n    }\n\n    task integrationTest(type: Test, dependsOn: [\"compileTestJava\"]) {\n      group = \"verification\"\n      description = \"Runs the Besu integration tests\"\n\n      jvmArgs = [\n        '--add-opens',\n        'java.base/java.util=ALL-UNNAMED',\n        '--add-opens',\n        'java.base/java.util.concurrent=ALL-UNNAMED'\n      ]\n      testClassesDirs = sourceSets.integrationTest.output.classesDirs\n      classpath = sourceSets.integrationTest.runtimeClasspath\n      outputs.upToDateWhen { false }\n      useJUnitPlatform {}\n    }\n  }\n\n  def sourceSetIsPopulated = { sourceSetName ->\n    def result = project.sourceSets.names.contains(sourceSetName) && !project.sourceSets.getAt(sourceSetName).allSource.empty\n    logger.info(\"Project = \" + project.name + \" Has Source Set (\" + sourceSetName + \") = \" + result + \"(\" + project.sourceSets.names + \")\")\n    return result\n  }\n\n\n  if (sourceSetIsPopulated(\"main\") || sourceSetIsPopulated(\"testSupport\") || project.name == \"platform\") {\n    apply plugin: 'com.jfrog.artifactory'\n    apply plugin: 'maven-publish'\n\n    publishing {\n      publications {\n        mavenJava(MavenPublication) {\n          groupId \"org.hyperledger.besu.internal\"\n          version \"${project.version}\"\n          if (sourceSetIsPopulated(\"main\")) {\n            from components.java\n            artifact sourcesJar\n            artifact javadocJar\n          }\n\n          if (sourceSetIsPopulated(\"testSupport\")) {\n            artifact testSupportJar\n          }\n          versionMapping {\n            usage('java-api') { fromResolutionOf('runtimeClasspath') }\n            usage('java-runtime') { fromResolutionResult() }\n          }\n          pom {\n            name = \"Besu - ${project.name}\"\n            url = 'http://github.com/hyperledger/besu'\n            licenses {\n              license {\n                name = 'The Apache License, Version 2.0'\n                url = 'http://www.apache.org/licenses/LICENSE-2.0.txt'\n              }\n            }\n            scm {\n              connection = 'scm:git:git://github.com/hyperledger/besu.git'\n              developerConnection = 'scm:git:ssh://github.com/hyperledger/besu.git'\n              url = 'https://github.com/hyperledger/besu'\n            }\n          }\n        }\n      }\n    }\n\n    def artifactoryUser = project.hasProperty('artifactoryUser') ? project.property('artifactoryUser') : System.getenv('ARTIFACTORY_USER')\n    def artifactoryKey = project.hasProperty('artifactoryApiKey') ? project.property('artifactoryApiKey') : System.getenv('ARTIFACTORY_KEY')\n    def artifactoryRepo = System.getenv('ARTIFACTORY_REPO') ?: 'besu-maven'\n    def artifactoryOrg = System.getenv('ARTIFACTORY_ORG') ?: 'hyperledger'\n\n    artifactory {\n      contextUrl = \"https://hyperledger.jfrog.io/${artifactoryOrg}\"\n      publish {\n        repository {\n          repoKey = \"${artifactoryRepo}\"\n          username = artifactoryUser\n          password = artifactoryKey\n        }\n        defaults {\n          publications('mavenJava', 'mavenJavaPlatform')\n          publishArtifacts = true\n          publishPom = true\n        }\n      }\n    }\n  }\n\n  tasks.withType(Test) {\n    // If GRADLE_MAX_TEST_FORKS is not set, use half the available processors\n    maxParallelForks = (System.getenv('GRADLE_MAX_TEST_FORKS') ?: (Runtime.runtime.availableProcessors().intdiv(2) ?: 1)).toInteger()\n  }\n\n  tasks.withType(JavaCompile) {\n    options.fork = true\n    options.incremental = true\n  }\n\n\n  configurations {\n    testSupportAnnotationProcessor.extendsFrom annotationProcessor\n    testSupportImplementation.extendsFrom implementation\n    integrationTestAnnotationProcessor.extendsFrom annotationProcessor\n    integrationTestImplementation.extendsFrom implementation\n    testSupportArtifacts\n  }\n\n  if (file('src/jmh').directory) {\n    apply plugin: 'me.champeau.jmh'\n\n    jmh {\n      // Allows to control JMH execution directly from the command line. I typical execution may look\n      // like:\n      //    gradle jmh -Pf=2 -Pwi=3 -Pi=5 -Pinclude=MyBench\n      // which will run 2 forks with 3 warmup iterations and 5 normal ones for each, and will only\n      // run the benchmark matching 'MyBench' (a regexp).\n      warmupForks = _intCmdArg('wf')\n      warmupIterations = _intCmdArg('wi')\n      fork = _intCmdArg('f')\n      iterations = _intCmdArg('i')\n      benchmarkMode = _strListCmdArg('bm')\n      includes = _strListCmdArg('include', [''])\n      humanOutputFile = project.file(\"${project.buildDir}/reports/jmh/results.txt\")\n      resultFormat = 'JSON'\n      duplicateClassesStrategy = DuplicatesStrategy.WARN\n    }\n\n    dependencies {\n      jmhAnnotationProcessor(platform(project(':platform')))\n      jmh 'org.slf4j:slf4j-api'\n    }\n  }\n\n  // making sure assemble task invokes integration test compile\n  afterEvaluate { project ->\n    if (project.tasks.findByName('compileIntegrationTestJava')) {\n      project.tasks.assemble.dependsOn compileIntegrationTestJava\n    }\n  }\n}\n\njar { enabled = false }\n\napply plugin: 'application'\napplication {\n  mainClass = 'org.hyperledger.besu.Besu'\n  applicationDefaultJvmArgs = [\n    '-Dvertx.disableFileCPResolving=true',\n    // BESU_HOME is replaced by a doFirst block in the run task.\n    '-Dbesu.home=BESU_HOME',\n    // We shutdown log4j ourselves, as otherwise this shutdown hook runs before our own and whatever\n    // happens during shutdown is not logged.\n    '-Dlog4j.shutdownHookEnabled=false',\n    // Disable JNI lookups in log4j messages to improve security\n    '-Dlog4j2.formatMsgNoLookups=true',\n    // Redirect java.util.logging loggers to use log4j2.\n    '-Djava.util.logging.manager=org.apache.logging.log4j.jul.LogManager',\n    // Suppress Java JPMS warnings.  Document the reason for each suppression.\n    // Bouncy Castle needs access to sun.security.provider, which is not open by default.\n    '--add-opens',\n    'java.base/sun.security.provider=ALL-UNNAMED',\n    // Jackson likes to access java.util.OptionalLong's constructor\n    '--add-opens',\n    'java.base/java.util=ALL-UNNAMED',\n    // suppress netty specific module warnings in debug\n    \"-Dio.netty.tryReflectionSetAccessible=true\",\n    \"--add-exports\",\n    \"java.base/jdk.internal.misc=ALL-UNNAMED\",\n    \"--add-opens\",\n    \"java.base/java.nio=ALL-UNNAMED\"\n  ]\n}\n\nrun {\n  args project.hasProperty(\"besu.run.args\") ? project.property(\"besu.run.args\").toString().split(\"\\\\s+\") : []\n  doFirst {\n    applicationDefaultJvmArgs = applicationDefaultJvmArgs.collect {\n      it.replace('BESU_HOME', \"$buildDir/besu\")\n    }\n  }\n}\n\ndef tweakStartScript(createScriptTask) {\n  def shortenWindowsClasspath = { line ->\n    line.replaceAll(/^set CLASSPATH=.*$/, \"set CLASSPATH=%APP_HOME%/lib/*\")\n  }\n\n  createScriptTask.unixScript.text = createScriptTask.unixScript.text.replace('BESU_HOME', '\\$APP_HOME')\n  createScriptTask.windowsScript.text = createScriptTask.windowsScript.text.replace('BESU_HOME', '%~dp0..')\n\n  // Prevent the error originating from the 8191 chars limit on Windows\n  createScriptTask.windowsScript.text =\n    createScriptTask.windowsScript\n    .readLines()\n    .collect(shortenWindowsClasspath)\n    .join('\\r\\n')\n}\n\nstartScripts {\n  defaultJvmOpts = application.applicationDefaultJvmArgs + [\n    \"-XX:G1ConcRefinementThreads=2\",\n    \"-XX:G1HeapWastePercent=15\",\n    \"-XX:MaxGCPauseMillis=100\",\n    \"-XX:StartFlightRecording,settings=default.jfc\",\n    \"-Xlog:jfr*=off\"\n  ]\n  unixStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/unixStartScript.txt\")\n  windowsStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/windowsStartScript.txt\")\n  doLast { tweakStartScript(startScripts) }\n}\n\ntask untunedStartScripts(type: CreateStartScripts) {\n  mainClass = 'org.hyperledger.besu.Besu'\n  classpath = startScripts.classpath\n  outputDir = startScripts.outputDir\n  applicationName = 'besu-untuned'\n  unixStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/unixStartScript.txt\")\n  windowsStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/windowsStartScript.txt\")\n  doLast { tweakStartScript(untunedStartScripts) }\n}\n\ntask evmToolStartScripts(type: CreateStartScripts) {\n  mainClass = 'org.hyperledger.besu.evmtool.EvmTool'\n  classpath = startScripts.classpath\n  outputDir = startScripts.outputDir\n  applicationName = 'evmtool'\n  defaultJvmOpts = [\n    \"-Dsecp256k1.randomize=false\"\n  ]\n  unixStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/unixStartScript.txt\")\n  windowsStartScriptGenerator.template = resources.text.fromFile(\"${projectDir}/besu/src/main/scripts/windowsStartScript.txt\")\n  doLast { tweakStartScript(evmToolStartScripts) }\n}\n\ntask autocomplete(type: JavaExec) {\n  dependsOn compileJava\n  def tempAutocompleteFile = File.createTempFile(\"besu\", \".autocomplete\")\n  standardOutput tempAutocompleteFile.newOutputStream()\n  outputs.file \"$buildDir/besu.autocomplete.sh\"\n\n  mainClass = application.mainClass\n  args \"generate-completion\"\n  classpath sourceSets.main.runtimeClasspath\n  doLast {\n    copy {\n      from tempAutocompleteFile\n      into \"$buildDir\"\n      rename tempAutocompleteFile.getName(), 'besu.autocomplete.sh'\n    }\n  }\n}\n\ndef archiveBuildVersion = project.hasProperty('release.releaseVersion') ? project.property('release.releaseVersion') : \"${rootProject.version}\"\n\ninstallDist { dependsOn checkLicense, untunedStartScripts, evmToolStartScripts }\n\ndistTar {\n  dependsOn checkLicense, autocomplete, untunedStartScripts, evmToolStartScripts\n  doFirst {\n    delete fileTree(dir: 'build/distributions', include: '*.tar.gz')\n  }\n  compression = Compression.GZIP\n  setVersion(archiveBuildVersion)\n  archiveExtension = 'tar.gz'\n}\n\ndistZip {\n  dependsOn checkLicense, autocomplete, untunedStartScripts, evmToolStartScripts\n  doFirst {\n    delete fileTree(dir: 'build/distributions', include: '*.zip')\n  }\n  setVersion(archiveBuildVersion)\n}\n\npublishing {\n  publications {\n    distArtifactory(MavenPublication) {\n      groupId = '.'\n      version = project.version\n      artifactId = 'besu'\n    }\n  }\n}\n\nartifactoryPublish {\n  dependsOn distTar\n  dependsOn distZip\n}\n\ndef dockerBuildVersion = project.hasProperty('release.releaseVersion') ? project.property('release.releaseVersion') : \"${rootProject.version}\"\ndef dockerOrgName = project.hasProperty('dockerOrgName') ? project.getProperty(\"dockerOrgName\") : \"hyperledger\"\ndef dockerArtifactName = project.hasProperty(\"dockerArtifactName\") ? project.getProperty(\"dockerArtifactName\") : \"besu\"\ndef dockerImageName = \"${dockerOrgName}/${dockerArtifactName}\"\n\n// rename the top level dir from besu-<version> to besu and this makes it really\n// simple for use in docker\ntasks.register(\"dockerDistUntar\") {\n  dependsOn distTar\n  dependsOn distZip\n  def dockerBuildDir = \"build/docker-besu/\"\n  def distTarFile = distTar.outputs.files.singleFile\n  def distTarFileName = distTar.outputs.files.singleFile.name.replace(\".tar.gz\", \"\")\n\n  doFirst {\n    new File(dockerBuildDir).mkdir()\n    copy {\n      from tarTree(distTarFile)\n      into(dockerBuildDir)\n    }\n    project.delete(files(\"${dockerBuildDir}/besu\"))\n    file(\"${dockerBuildDir}/${distTarFileName}\").renameTo(\"${dockerBuildDir}/besu\")\n  }\n}\n\ntask distDocker {\n  dependsOn dockerDistUntar\n  inputs.dir(\"build/docker-besu/\")\n  def dockerBuildDir = \"build/docker-besu/\"\n\n  doLast {\n    copy {\n      from file(\"${projectDir}/docker/Dockerfile\")\n      into(dockerBuildDir)\n    }\n    exec {\n      def image = \"${dockerImageName}:${dockerBuildVersion}\"\n      def dockerPlatform = \"\"\n      if (project.hasProperty('docker-platform')){\n        dockerPlatform = \"--platform ${project.getProperty('docker-platform')}\"\n        println \"Building for platform ${project.getProperty('docker-platform')}\"\n      }\n      def gitDetails = getGitCommitDetails(7)\n      executable shell\n      workingDir dockerBuildDir\n      args \"-c\", \"docker build ${dockerPlatform} --build-arg BUILD_DATE=${buildTime()} --build-arg VERSION=${dockerBuildVersion} --build-arg VCS_REF=${gitDetails.hash} -t ${image} .\"\n    }\n  }\n}\n\ntask testDocker {\n  dependsOn distDocker\n  def dockerReportsDir = \"docker/reports/\"\n\n  doFirst {\n    new File(dockerReportsDir).mkdir()\n  }\n\n  doLast {\n    exec {\n      def image = project.hasProperty('release.releaseVersion') ? \"${dockerImageName}:\" + project.property('release.releaseVersion') : \"${dockerImageName}:${project.version}\"\n      workingDir \"${projectDir}/docker\"\n      executable shell\n      args \"-c\", \"./test.sh ${image}\"\n    }\n  }\n}\n\ntask dockerUpload {\n  dependsOn distDocker\n  def architecture = System.getenv('architecture')\n  def image = \"${dockerImageName}:${dockerBuildVersion}\"\n  def additionalTags = []\n\n  if (project.hasProperty('branch') && project.property('branch') == 'main') {\n    additionalTags.add('develop')\n  }\n\n  if (!isInterimBuild(dockerBuildVersion)) {\n    additionalTags.add(dockerBuildVersion.split(/\\./)[0..1].join('.'))\n  }\n\n  doLast {\n    exec {\n      def archVariantImage = \"${image}-${architecture}\"\n      def cmd = \"docker tag '${image}' '${archVariantImage}' && docker push '${archVariantImage}'\"\n      println \"Executing '${cmd}'\"\n      executable shell\n      args \"-c\", cmd\n    }\n  }\n}\n\ntask dockerUploadRelease {\n  def archs = [\"arm64\", \"amd64\"]\n  def image = \"${dockerImageName}:${dockerBuildVersion}\"\n\n  doLast {\n    for (def architecture in archs) {\n\n      exec {\n        def cmd = \"docker pull '${image}-${architecture}' && docker tag '${image}-${architecture}' '${dockerImageName}:latest-${architecture}'\"\n        println \"Executing '${cmd}'\"\n        executable shell\n        args \"-c\", cmd\n      }\n      exec {\n        def cmd = \"docker push '${dockerImageName}:latest-${architecture}'\"\n        println \"Executing '${cmd}'\"\n        executable shell\n        args \"-c\", cmd\n      }\n\n\n      exec {\n        def archImage = \"${image}-${architecture}\"\n        def cmd = \"docker pull '${archImage}' && docker tag ${archImage} '${dockerImageName}:latest-${architecture}'\"\n        println \"Executing '${cmd}'\"\n        executable shell\n        args \"-c\", cmd\n      }\n      exec {\n        def cmd = \"docker push '${dockerImageName}:latest-${architecture}'\"\n        println \"Executing '${cmd}'\"\n        executable shell\n        args \"-c\", cmd\n      }\n    }\n  }\n}\n\ntask manifestDocker {\n  def image = \"${dockerImageName}:${dockerBuildVersion}\"\n  def archs = [\n    \"arm64\",\n    \"amd64\"] //TODO: this assumes dockerUpload task has already been run on 2 different archs!\n  doLast {\n    exec {\n      def targets = \"\"\n      archs.forEach { arch -> targets += \"'${image}-${arch}' \" }\n      def cmd = \"docker manifest create '${image}' ${targets}\"\n      println \"Executing '${cmd}'\"\n      executable shell\n      args \"-c\", cmd\n    }\n    exec {\n      def cmd = \"docker manifest push '${image}'\"\n      println \"Executing '${cmd}'\"\n      executable shell\n      args \"-c\", cmd\n    }\n  }\n}\n\ntask manifestDockerRelease {\n  def archs = [\"arm64\", \"amd64\"]\n  def baseTag = \"${dockerImageName}:latest\";\n\n  doLast {\n\n    exec {\n      def targets = \"\"\n      archs.forEach { arch -> targets += \"'${baseTag}-${arch}' \" }\n      def cmd = \"docker manifest create '${baseTag}' ${targets} --amend\"\n      println \"Executing '${cmd}'\"\n      executable shell\n      args \"-c\", cmd\n    }\n    exec {\n      def cmd = \"docker manifest push '${baseTag}'\"\n      println \"Executing '${cmd}'\"\n      executable shell\n      args \"-c\", cmd\n    }\n  }\n}\n\ndef sep = Pattern.quote(File.separator)\n\njacocoTestReport {\n  reports {\n    xml.required = true\n  }\n}\n\n// http://label-schema.org/rc1/\n// using the RFC3339 format \"2016-04-12T23:20:50.52Z\"\ndef buildTime() {\n  def df = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm'Z'\")\n  df.setTimeZone(TimeZone.getTimeZone(\"UTC\"))\n  return df.format(new Date())\n}\n\n@Memoized\ndef calculateVersion() {\n  // Regex pattern for basic calendar versioning, with provision to omit patch rev\n  def calVerPattern = ~/\\d+\\.\\d+(\\.\\d+)?(-.*)?/\n\n  if (project.hasProperty('version') && (project.version =~ calVerPattern)) {\n    if (project.hasProperty('versionappendcommit') && project.versionappendcommit == \"true\") {\n      def gitDetails = getGitCommitDetails(7) // Adjust length as needed\n      return \"${project.version}-${gitDetails.hash}\"\n    }\n    return \"${project.version}\"\n  } else {\n    // If no version is supplied or it doesn't match the semantic versioning, calculate from git\n    println(\"Generating project version as supplied is version not semver: ${project.version}\")\n    def gitDetails = getGitCommitDetails(7) // Adjust length as needed\n    return \"${gitDetails.date}-develop-${gitDetails.hash}\"\n  }\n}\n\ndef getGitCommitDetails(length = 8) {\n  try {\n    def gitFolder = \"$projectDir/.git/\"\n    if (!file(gitFolder).isDirectory()) {\n      gitFolder = file(gitFolder).text.substring(length).trim() + \"/\"\n    }\n    def takeFromHash = length\n    def head = new File(gitFolder + \"HEAD\").text.split(\":\")\n    def isCommit = head.length == 1\n\n    def commitHash, refHeadFile\n    if (isCommit) {\n      commitHash = head[0].trim().take(takeFromHash)\n      refHeadFile = new File(gitFolder + \"HEAD\")\n    } else {\n      refHeadFile = new File(gitFolder + head[1].trim())\n      commitHash = refHeadFile.text.trim().take(takeFromHash)\n    }\n\n    // Use head file modification time as a proxy for the build date\n    def lastModified = new Date(refHeadFile.lastModified())\n    // Format the date as \"yy.M\" (e.g. 24.3 for March 2024)\n    def formattedDate = new SimpleDateFormat(\"yy.M\").format(lastModified)\n\n    return [hash: commitHash, date: formattedDate]\n  } catch (Exception e) {\n    logger.warn('Could not calculate git commit details, using defaults (run with --info for stacktrace)')\n    logger.info('Error retrieving git commit details', e)\n    return [hash: \"xxxxxxxx\", date: \"00.0\"]\n  }\n}\n\n// Takes the version and if it contains SNAPSHOT, alpha, beta or RC in version then return true indicating an interim build\ndef isInterimBuild(dockerBuildVersion) {\n  return (dockerBuildVersion ==~ /.*-SNAPSHOT/) || (dockerBuildVersion ==~ /.*-alpha/)\n  || (dockerBuildVersion ==~ /.*-beta/) || (dockerBuildVersion ==~ /.*-RC.*/)\n  || (dockerBuildVersion ==~ /.*develop.*/)\n}\n\ntasks.register(\"verifyDistributions\") {\n  dependsOn distTar\n  dependsOn distZip\n  def distTarFile = distTar.outputs.files.singleFile\n  def distZipFile = distZip.outputs.files.singleFile\n  def minDistributionSize = 20000000\n\n  // Sanity check the distributions by checking they are at least a reasonable size\n  doFirst {\n    if (distTarFile.length() < minDistributionSize) {\n      throw new GradleException(\"Distribution tar is suspiciously small: \" + distTarFile.length() + \" bytes\")\n    }\n    if (distZipFile.length() < minDistributionSize) {\n      throw new GradleException(\"Distribution zip is suspiciously small: \" + distZipFile.length() + \" bytes\")\n    }\n  }\n}\n\ndependencies {\n  errorprone 'com.google.errorprone:error_prone_core'\n  // https://github.com/hyperledger/besu-errorprone-checks/\n  errorprone 'org.hyperledger.besu:besu-errorprone-checks'\n  implementation project(':besu')\n  implementation project(':ethereum:evmtool')\n}\n\n@CompileStatic\nclass BouncyCastleCapability implements ComponentMetadataRule {\n  void execute(ComponentMetadataContext context) {\n    context.details.with {\n      if (id.group == \"org.bouncycastle\") {\n        if(id.name == \"bcprov-jdk15on\") {\n          allVariants {\n            it.withCapabilities {\n              it.addCapability(\"org.bouncycastle\", \"bcprov-jdk18on\", \"0\")\n            }\n          }\n        } else if(id.name == \"bcpkix-jdk15on\") {\n          allVariants {\n            it.withCapabilities {\n              it.addCapability(\"org.bouncycastle\", \"bcpkix-jdk18on\", \"0\")\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\ndistributions {\n  main {\n    contents {\n      from(\"./LICENSE\") { into \".\" }\n      from(\"build/reports/license/license-dependency.html\") { into \".\" }\n      from(\"./docs/GettingStartedBinaries.md\") { into \".\" }\n      from(\"./docs/DocsArchive0.8.0.html\") { into \".\" }\n      from(\"./besu/src/main/scripts/besu-entry.sh\") { into \"./bin/\" }\n      from(autocomplete) { into \".\" }\n    }\n  }\n}\n\nbuild.dependsOn verifyDistributions\nartifactoryPublish.dependsOn verifyDistributions\nartifactoryPublish.mustRunAfter(distTar)\nartifactoryPublish.mustRunAfter(distZip)\nartifactoryPublish.mustRunAfter(javadocJar)\n"
        },
        "database": null,
        "build_system": "Gradle",
        "config_files": {
            "ethereum/evmtool/src/main/docker/Dockerfile": "\nFROM ubuntu:24.04\nARG VERSION=\"dev\"\nENV NO_PROXY_CACHE=\"-o Acquire::BrokenProxy=true -o Acquire::http::No-Cache=true -o Acquire::http::Pipeline-Depth=0\"\n\n# Update and install dependencies without using any cache\nRUN apt-get update $NO_PROXY_CACHE  && \\\n  # $NO_PROXY_CACHE must not be used here or otherwise will trigger a hadolint error\n  apt-get -o Acquire::BrokenProxy=true -o Acquire::http::No-Cache=true -o Acquire::http::Pipeline-Depth=0 \\\n    --no-install-recommends -q --assume-yes install openjdk-21-jre-headless=21* adduser=3* && \\\n  # Clean apt cache  \\\n  apt-get clean  && \\\n  rm -rf /var/cache/apt/archives/* /var/cache/apt/archives/partial/*  && \\\n  rm -rf /var/lib/apt/lists/*  && \\\n  # Creating a user for besu\n  adduser --disabled-password --gecos \"\" --home /opt/besu besu  && \\\n  chown besu:besu /opt/besu\n\nUSER besu\nWORKDIR /opt/besu-evmtool\n\nCOPY --chown=besu:besu besu-evmtool /opt/besu-evmtool/\n\nENV PATH=\"/opt/besu-evmtool/bin:${PATH}\"\nENTRYPOINT [\"evmtool\"]\n\n# Build-time metadata as defined at http://label-schema.org\nARG BUILD_DATE\nARG VCS_REF\nARG VERSION\nLABEL org.label-schema.build-date=$BUILD_DATE \\\n      org.label-schema.name=\"Besu EVMTool\" \\\n      org.label-schema.description=\"EVM Execution Tool\" \\\n      org.label-schema.url=\"https://besu.hyperledger.org/\" \\\n      org.label-schema.vcs-ref=$VCS_REF \\\n      org.label-schema.vcs-url=\"https://github.com/hyperledger/besu.git\" \\\n      org.label-schema.vendor=\"Hyperledger\" \\\n      org.label-schema.version=$VERSION \\\n      org.label-schema.schema-version=\"1.0\""
        },
        "static_files": {
            "ethereum/evmtool/src/main/resources/log4j2.xml": "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<Configuration level=\"WARN\">\n    <Properties>\n        <Property name=\"root.log.level\">INFO</Property>\n    </Properties>\n\n    <Appenders>\n        <Console name=\"Console\" target=\"SYSTEM_OUT\">\n            <PatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSSZZZ} | %t | %-5level | %c{1} | %msgc%n\" />\n        </Console>\n    </Appenders>\n    <Loggers>\n        <Root level=\"${sys:root.log.level}\">\n            <AppenderRef ref=\"Console\" />\n        </Root>\n    </Loggers>\n</Configuration>\n"
        }
    },
    "project_structure": {
        "files": [
            "Dockerfile"
        ],
        "folders": []
    }
}